// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `hex_decode_32`, `hex_encode`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

Future<String> deriveFeedTagHex({
  required String publisherPubkeyHex,
  required int namespace,
}) => VeilBridgeApi.instance.api.crateApiDeriveFeedTagHex(
  publisherPubkeyHex: publisherPubkeyHex,
  namespace: namespace,
);

Future<String> deriveRvTagHex({
  required String recipientPubkeyHex,
  required int epoch,
  required int namespace,
}) => VeilBridgeApi.instance.api.crateApiDeriveRvTagHex(
  recipientPubkeyHex: recipientPubkeyHex,
  epoch: epoch,
  namespace: namespace,
);

Future<BigInt> currentEpochSeconds({
  required BigInt now,
  required BigInt epochSeconds,
}) => VeilBridgeApi.instance.api.crateApiCurrentEpochSeconds(
  now: now,
  epochSeconds: epochSeconds,
);

Future<ShardMeta> decodeShardMeta({required List<int> bytes}) =>
    VeilBridgeApi.instance.api.crateApiDecodeShardMeta(bytes: bytes);

Future<ObjectMeta> decodeObjectMeta({required List<int> bytes}) =>
    VeilBridgeApi.instance.api.crateApiDecodeObjectMeta(bytes: bytes);

Future<String> deriveObjectRootHex({required List<int> objectBytes}) =>
    VeilBridgeApi.instance.api.crateApiDeriveObjectRootHex(
      objectBytes: objectBytes,
    );

Future<Uint8List> reconstructObjectPaddedFromShards({
  required List<Uint8List> shardBytes,
  required String expectedRootHex,
}) => VeilBridgeApi.instance.api.crateApiReconstructObjectPaddedFromShards(
  shardBytes: shardBytes,
  expectedRootHex: expectedRootHex,
);

class ObjectMeta {
  final int version;
  final int namespace;
  final int epoch;
  final int flags;
  final bool signed;
  final bool public;
  final bool ackRequested;
  final bool batched;
  final String tagHex;
  final String objectRootHex;
  final String? senderPubkeyHex;
  final String nonceHex;
  final BigInt ciphertextLen;
  final BigInt paddingLen;

  const ObjectMeta({
    required this.version,
    required this.namespace,
    required this.epoch,
    required this.flags,
    required this.signed,
    required this.public,
    required this.ackRequested,
    required this.batched,
    required this.tagHex,
    required this.objectRootHex,
    this.senderPubkeyHex,
    required this.nonceHex,
    required this.ciphertextLen,
    required this.paddingLen,
  });

  @override
  int get hashCode =>
      version.hashCode ^
      namespace.hashCode ^
      epoch.hashCode ^
      flags.hashCode ^
      signed.hashCode ^
      public.hashCode ^
      ackRequested.hashCode ^
      batched.hashCode ^
      tagHex.hashCode ^
      objectRootHex.hashCode ^
      senderPubkeyHex.hashCode ^
      nonceHex.hashCode ^
      ciphertextLen.hashCode ^
      paddingLen.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ObjectMeta &&
          runtimeType == other.runtimeType &&
          version == other.version &&
          namespace == other.namespace &&
          epoch == other.epoch &&
          flags == other.flags &&
          signed == other.signed &&
          public == other.public &&
          ackRequested == other.ackRequested &&
          batched == other.batched &&
          tagHex == other.tagHex &&
          objectRootHex == other.objectRootHex &&
          senderPubkeyHex == other.senderPubkeyHex &&
          nonceHex == other.nonceHex &&
          ciphertextLen == other.ciphertextLen &&
          paddingLen == other.paddingLen;
}

class ShardMeta {
  final int version;
  final int namespace;
  final int epoch;
  final String tagHex;
  final String objectRootHex;
  final int k;
  final int n;
  final int index;
  final BigInt payloadLen;

  const ShardMeta({
    required this.version,
    required this.namespace,
    required this.epoch,
    required this.tagHex,
    required this.objectRootHex,
    required this.k,
    required this.n,
    required this.index,
    required this.payloadLen,
  });

  @override
  int get hashCode =>
      version.hashCode ^
      namespace.hashCode ^
      epoch.hashCode ^
      tagHex.hashCode ^
      objectRootHex.hashCode ^
      k.hashCode ^
      n.hashCode ^
      index.hashCode ^
      payloadLen.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ShardMeta &&
          runtimeType == other.runtimeType &&
          version == other.version &&
          namespace == other.namespace &&
          epoch == other.epoch &&
          tagHex == other.tagHex &&
          objectRootHex == other.objectRootHex &&
          k == other.k &&
          n == other.n &&
          index == other.index &&
          payloadLen == other.payloadLen;
}
