<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VEIL Node Admin</title>
    <style>
      :root {
        --bg: #0b1220;
        --panel: #111827;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --border: #1f2937;
        --accent: #22d3ee;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        color: var(--text);
        background: radial-gradient(900px 600px at 10% -10%, rgba(34, 211, 238, 0.2), transparent), var(--bg);
      }
      main {
        max-width: 920px;
        margin: 0 auto;
        padding: 24px;
      }
      .card {
        background: linear-gradient(160deg, rgba(17, 24, 39, 0.95), rgba(17, 24, 39, 0.75));
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 16px;
        margin-bottom: 16px;
      }
      h1, h2 { margin: 0 0 10px; }
      .muted { color: var(--muted); }
      input {
        width: 100%;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #0b1324;
        color: var(--text);
      }
      button {
        margin-top: 10px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 8px;
        color: var(--text);
        background: #0c1a2a;
        cursor: pointer;
      }
      button.primary {
        background: linear-gradient(135deg, var(--accent), #3b82f6);
        color: #0b1220;
        border: none;
        font-weight: 600;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
      }
      .stat {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        background: rgba(2, 6, 23, 0.55);
      }
      .label { color: var(--muted); font-size: 0.8rem; }
      .value { margin-top: 4px; font-family: ui-monospace, Menlo, Consolas, monospace; }
      #adminPanel { display: none; }
      #status { margin-top: 8px; color: var(--muted); }
      .row { display: flex; gap: 8px; flex-wrap: wrap; }
      table {
        width: 100%;
        border-collapse: collapse;
        font-family: ui-monospace, Menlo, Consolas, monospace;
        font-size: 0.85rem;
      }
      th, td {
        text-align: left;
        border-bottom: 1px solid var(--border);
        padding: 8px 6px;
      }
      th { color: var(--muted); }
      .toggle-grid {
        display: grid;
        gap: 10px;
      }
      .toggle-item {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        background: rgba(2, 6, 23, 0.55);
      }
      .toggle-group {
        margin-top: 8px;
      }
      .toggle-group-title {
        font-weight: 700;
        margin-bottom: 8px;
      }
      .toggle-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .toggle-key {
        font-family: ui-monospace, Menlo, Consolas, monospace;
        font-size: 0.78rem;
        color: var(--muted);
        margin-top: 4px;
      }
      .badge {
        display: inline-block;
        margin-top: 6px;
        font-size: 0.72rem;
        color: #fcd34d;
        border: 1px solid rgba(252, 211, 77, 0.35);
        background: rgba(120, 53, 15, 0.3);
        border-radius: 999px;
        padding: 2px 8px;
      }
      .log-entry { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 2px; }
      .log-time { color: var(--muted); margin-right: 8px; font-size: 0.75rem; }
      .log-level { font-weight: 700; margin-right: 8px; width: 50px; display: inline-block; }
      .log-level-ERROR { color: #f87171; }
      .log-level-WARN { color: #fbbf24; }
      .log-level-INFO { color: #34d399; }
      .log-level-DEBUG { color: #60a5fa; }
      .log-target { color: var(--accent); margin-right: 8px; opacity: 0.8; font-size: 0.75rem; }
    </style>
  </head>
  <body>
    <main>
      <div class="card">
        <h1>VEIL Admin</h1>
        <div class="muted">Login with the VPS node Nostr identity (`nsec` or 32-byte hex secret).</div>
      </div>

      <div class="card" id="loginPanel">
        <h2>Authentication</h2>
        <div class="muted" id="serverPubkey">Server pubkey: loading…</div>
        <input id="secretInput" type="password" placeholder="nsec1... or hex secret" autocomplete="off" />
        <div class="row">
          <button class="primary" id="loginBtn">Login</button>
          <button id="logoutBtn" type="button">Logout</button>
        </div>
        <div id="status">Not authenticated.</div>
      </div>

      <div class="card" id="adminPanel">
        <h2>Admin Stats</h2>
        <div class="row" style="margin-bottom: 10px;">
          <button id="restartNodeBtn" type="button">Restart Node</button>
        </div>
        <div class="grid">
          <div class="stat"><div class="label">Ticks</div><div class="value" id="ticks">-</div></div>
          <div class="stat"><div class="label">Delivered</div><div class="value" id="delivered">-</div></div>
          <div class="stat"><div class="label">Fast Inbound</div><div class="value" id="fastIn">-</div></div>
          <div class="stat"><div class="label">Fallback Inbound</div><div class="value" id="fallbackIn">-</div></div>
          <div class="stat"><div class="label">Fast Outbound Err</div><div class="value" id="fastErr">-</div></div>
          <div class="stat"><div class="label">Fallback Outbound Err</div><div class="value" id="fallbackErr">-</div></div>
          <div class="stat"><div class="label">Nostr Events</div><div class="value" id="nostrEvents">-</div></div>
          <div class="stat"><div class="label">Nostr Bytes</div><div class="value" id="nostrBytes">-</div></div>
          <div class="stat"><div class="label">Peers</div><div class="value" id="peers">-</div></div>
        </div>
      </div>

      <div class="card" id="settingsPanel" style="display: none;">
        <h2>Node Settings</h2>
        <div class="muted">Changes are persisted immediately, but most settings apply after node restart.</div>
        <div style="margin-top: 10px;" class="row">
          <input id="settingKeyInput" type="text" placeholder="VEIL_VPS_..." style="flex: 1; min-width: 260px;" />
          <input id="settingValueInput" type="text" placeholder="value" style="flex: 2; min-width: 260px;" />
        </div>
        <div class="row">
          <button class="primary" id="saveSettingBtn">Save setting</button>
          <button id="deleteSettingBtn" type="button">Delete setting</button>
          <button id="refreshSettingsBtn" type="button">Refresh list</button>
        </div>
        <div id="settingsStatus" class="muted" style="margin-top: 8px;">Idle.</div>
        <div style="margin-top: 10px; max-height: 320px; overflow: auto;">
          <table>
            <thead>
              <tr><th>Key</th><th>Value</th></tr>
            </thead>
            <tbody id="settingsTableBody"></tbody>
          </table>
        </div>
      </div>

      <div class="card" id="toggleSettingsPanel" style="display: none;">
        <h2>Toggle Settings</h2>
        <div class="muted">Boolean settings with instant on/off controls. Restart badge means service restart needed to apply.</div>
        <div id="toggleSettingsStatus" class="muted" style="margin-top: 8px;">Idle.</div>
        <div id="toggleSettingsList" class="toggle-grid" style="margin-top: 10px;"></div>
      </div>

      <div class="card" id="logsPanel" style="display: none;">
        <div class="toggle-header">
          <h2>Server Logs</h2>
          <button id="refreshLogsBtn" type="button">Refresh Logs</button>
        </div>
        <div id="logsStatus" class="muted" style="margin-top: 8px;">Idle.</div>
        <div id="logsList" style="margin-top: 10px; max-height: 400px; overflow: auto; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; font-family: ui-monospace, monospace; font-size: 0.8rem; white-space: pre-wrap;"></div>
      </div>

      <div class="card" id="identityPanel" style="display: none;">
        <h2>Server Identity Export</h2>
        <div class="muted">Keep this secret offline. Anyone with this key can control node identity.</div>
        <div style="margin-top: 10px;">
          <div class="label">nsec</div>
          <div class="value" id="serverNsec">-</div>
          <button id="copyNsecBtn" type="button">Copy nsec</button>
        </div>
        <div style="margin-top: 12px;">
          <div class="label">Secret (hex)</div>
          <div class="value" id="serverHex">-</div>
          <button id="copyHexBtn" type="button">Copy hex</button>
        </div>
        <div class="muted" id="identityStatus" style="margin-top: 8px;">Locked.</div>
      </div>
    </main>

    <script>
      const serverPubkeyEl = document.getElementById("serverPubkey");
      const statusEl = document.getElementById("status");
      const adminPanelEl = document.getElementById("adminPanel");
      const restartNodeBtn = document.getElementById("restartNodeBtn");
      const loginBtn = document.getElementById("loginBtn");
      const logoutBtn = document.getElementById("logoutBtn");
      const secretInput = document.getElementById("secretInput");
      const settingsPanelEl = document.getElementById("settingsPanel");
      const settingKeyInput = document.getElementById("settingKeyInput");
      const settingValueInput = document.getElementById("settingValueInput");
      const saveSettingBtn = document.getElementById("saveSettingBtn");
      const deleteSettingBtn = document.getElementById("deleteSettingBtn");
      const refreshSettingsBtn = document.getElementById("refreshSettingsBtn");
      const settingsStatusEl = document.getElementById("settingsStatus");
      const settingsTableBody = document.getElementById("settingsTableBody");
      const toggleSettingsPanelEl = document.getElementById("toggleSettingsPanel");
      const toggleSettingsStatusEl = document.getElementById("toggleSettingsStatus");
      const toggleSettingsListEl = document.getElementById("toggleSettingsList");
      const logsPanelEl = document.getElementById("logsPanel");
      const logsStatusEl = document.getElementById("logsStatus");
      const logsListEl = document.getElementById("logsList");
      const refreshLogsBtn = document.getElementById("refreshLogsBtn");
      const identityPanelEl = document.getElementById("identityPanel");
      const serverNsecEl = document.getElementById("serverNsec");
      const serverHexEl = document.getElementById("serverHex");
      const identityStatusEl = document.getElementById("identityStatus");
      const copyNsecBtn = document.getElementById("copyNsecBtn");
      const copyHexBtn = document.getElementById("copyHexBtn");
      const TOGGLE_SETTINGS = [
        { key: "VEIL_VPS_OPEN_RELAY", label: "Open Relay", group: "Network", description: "Accept/follow non-blocked peers and tags.", defaultValue: false, restartRequired: true },
        { key: "VEIL_VPS_NOSTR_BRIDGE_ENABLED", label: "Nostr Bridge", group: "Nostr", description: "Ingest Nostr relay events into VEIL.", defaultValue: false, restartRequired: true },
        { key: "VEIL_VPS_ADAPTIVE_LANE_SCORING", label: "Adaptive Lane Scoring", group: "Network", description: "Auto-tune transport lane preference.", defaultValue: true, restartRequired: true },
        { key: "VEIL_VPS_PROBABILISTIC_FORWARDING", label: "Probabilistic Forwarding", group: "Network", description: "Reduce forwarding of over-replicated shards.", defaultValue: true, restartRequired: true },
        { key: "VEIL_VPS_BLOOM_EXCHANGE", label: "Bloom Exchange", group: "Transport", description: "Exchange Bloom filters for shard dedupe.", defaultValue: true, restartRequired: true },
      ];
      let latestSettingsMap = {};

      function token() {
        return localStorage.getItem("veil_admin_token") || "";
      }

      function parseMetricsText(text) {
        const out = {};
        for (const rawLine of text.split("\n")) {
          const line = rawLine.trim();
          if (!line || line.startsWith("#")) continue;
          const parts = line.split(/\s+/);
          if (parts.length >= 2) out[parts[0]] = parts[1];
        }
        return out;
      }

      async function fetchAdmin(path) {
        return fetch(path, {
          headers: { Authorization: `Bearer ${token()}` },
          cache: "no-store",
        });
      }

      function setLoggedIn(isLoggedIn) {
        adminPanelEl.style.display = isLoggedIn ? "block" : "none";
        settingsPanelEl.style.display = isLoggedIn ? "block" : "none";
        toggleSettingsPanelEl.style.display = isLoggedIn ? "block" : "none";
        logsPanelEl.style.display = isLoggedIn ? "block" : "none";
        identityPanelEl.style.display = isLoggedIn ? "block" : "none";
      }

      async function refreshStatus() {
        try {
          const res = await fetchAdmin("/admin-api/status");
          const body = await res.json();
          serverPubkeyEl.textContent = `Server pubkey: ${body.server_pubkey || "unknown"}`;
          const ok = Boolean(body.ok);
          setLoggedIn(ok);
          statusEl.textContent = ok ? "Authenticated." : "Not authenticated.";
          if (ok) {
            await refreshAdminStats();
            await refreshSettingsList();
            await refreshIdentityExport();
            await refreshLogs();
          }
        } catch (_) {
          statusEl.textContent = "Status check failed.";
        }
      }

      async function refreshIdentityExport() {
        identityStatusEl.textContent = "Loading identity export…";
        const res = await fetchAdmin("/admin-api/identity");
        const body = await res.json().catch(() => ({}));
        if (!res.ok || !body.ok) {
          identityStatusEl.textContent = body.error || "Failed to load identity export.";
          return;
        }
        serverNsecEl.textContent = body.server_secret_nsec || "-";
        serverHexEl.textContent = body.server_secret_hex || "-";
        identityStatusEl.textContent = "Loaded.";
      }

      function renderSettings(items) {
        latestSettingsMap = {};
        settingsTableBody.innerHTML = "";
        for (const item of items) {
          const tr = document.createElement("tr");
          const keyTd = document.createElement("td");
          const valueTd = document.createElement("td");
          latestSettingsMap[item[0]] = item[1];
          keyTd.textContent = item[0];
          valueTd.textContent = item[1];
          tr.appendChild(keyTd);
          tr.appendChild(valueTd);
          tr.addEventListener("click", () => {
            settingKeyInput.value = item[0];
            settingValueInput.value = item[1];
          });
          settingsTableBody.appendChild(tr);
        }
        renderToggleSettings();
      }

      function parseBoolValue(rawValue, defaultValue) {
        if (rawValue == null) return defaultValue;
        const v = String(rawValue).trim().toLowerCase();
        if (["1", "true", "yes", "on", "enabled"].includes(v)) return true;
        if (["0", "false", "no", "off", "disabled"].includes(v)) return false;
        return defaultValue;
      }

      async function upsertSetting(key, value) {
        return fetch("/admin-api/settings", {
          method: "POST",
          headers: {
            Authorization: `Bearer ${token()}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ key, value }),
        });
      }

      function renderToggleSettings() {
        toggleSettingsListEl.innerHTML = "";
        const groups = {};
        for (const config of TOGGLE_SETTINGS) {
          const groupName = config.group || "Other";
          if (!groups[groupName]) {
            groups[groupName] = [];
          }
          groups[groupName].push(config);
        }
        for (const groupName of Object.keys(groups)) {
          const section = document.createElement("div");
          section.className = "toggle-group";
          const sectionTitle = document.createElement("div");
          sectionTitle.className = "toggle-group-title";
          sectionTitle.textContent = groupName;
          section.appendChild(sectionTitle);

          for (const config of groups[groupName]) {
          const wrapper = document.createElement("div");
          wrapper.className = "toggle-item";

          const header = document.createElement("div");
          header.className = "toggle-header";

          const titleWrap = document.createElement("div");
          const title = document.createElement("div");
          title.textContent = config.label;
          title.style.fontWeight = "600";
          const desc = document.createElement("div");
          desc.className = "muted";
          desc.style.fontSize = "0.82rem";
          desc.textContent = config.description;
          const key = document.createElement("div");
          key.className = "toggle-key";
          key.textContent = config.key;
          titleWrap.appendChild(title);
          titleWrap.appendChild(desc);
          titleWrap.appendChild(key);
          if (config.restartRequired) {
            const badge = document.createElement("span");
            badge.className = "badge";
            badge.textContent = "Restart required";
            titleWrap.appendChild(badge);
          }

          const input = document.createElement("input");
          input.type = "checkbox";
          input.style.width = "20px";
          input.style.height = "20px";
          input.checked = parseBoolValue(latestSettingsMap[config.key], config.defaultValue);
          input.addEventListener("change", async () => {
            const newValue = input.checked ? "1" : "0";
            const previous = !input.checked;
            toggleSettingsStatusEl.textContent = `Saving ${config.key}=${newValue}…`;
            const res = await upsertSetting(config.key, newValue);
            const body = await res.json().catch(() => ({}));
            if (!res.ok || !body.ok) {
              input.checked = previous;
              toggleSettingsStatusEl.textContent = body.error || `Failed to save ${config.key}.`;
              return;
            }
            latestSettingsMap[config.key] = newValue;
            toggleSettingsStatusEl.textContent = config.restartRequired
              ? `Saved ${config.key}=${newValue}. Restart node to apply.`
              : `Saved ${config.key}=${newValue}.`;
            await refreshSettingsList();
          });

          header.appendChild(titleWrap);
          header.appendChild(input);
          wrapper.appendChild(header);
          section.appendChild(wrapper);
          }
          toggleSettingsListEl.appendChild(section);
        }
      }

      async function refreshSettingsList() {
        settingsStatusEl.textContent = "Loading settings…";
        const res = await fetchAdmin("/admin-api/settings");
        const body = await res.json().catch(() => ({}));
        if (!res.ok || !body.ok || !Array.isArray(body.items)) {
          settingsStatusEl.textContent = body.error || "Failed to load settings.";
          return;
        }
        renderSettings(body.items);
        settingsStatusEl.textContent = `Loaded ${body.items.length} settings.`;
      }

      async function refreshAdminStats() {
        const [metricsRes, peersRes] = await Promise.all([
          fetchAdmin("/admin-api/metrics"),
          fetchAdmin("/admin-api/peers?limit=1000"),
        ]);
        if (!metricsRes.ok || !peersRes.ok) {
          statusEl.textContent = "Admin data fetch failed.";
          return;
        }
        const metrics = parseMetricsText(await metricsRes.text());
        const peersCount = (await peersRes.text())
          .split("\n")
          .map((v) => v.trim())
          .filter((v) => v.length > 0).length;

        document.getElementById("ticks").textContent = metrics.veil_ticks_total || "-";
        document.getElementById("delivered").textContent = metrics.veil_delivered_total || "-";
        document.getElementById("fastIn").textContent = metrics.veil_fast_inbound || "-";
        document.getElementById("fallbackIn").textContent = metrics.veil_fallback_inbound || "-";
        document.getElementById("fastErr").textContent = metrics.veil_fast_outbound_err || "-";
        document.getElementById("fallbackErr").textContent = metrics.veil_fallback_outbound_err || "-";
        document.getElementById("nostrEvents").textContent = metrics.veil_nostr_bridge_events_total || "0";
        document.getElementById("nostrBytes").textContent = metrics.veil_nostr_bridge_payload_bytes_total || "0";
        document.getElementById("peers").textContent = String(peersCount);
      }

      async function refreshLogs() {
        logsStatusEl.textContent = "Loading logs…";
        try {
          const res = await fetchAdmin("/admin-api/logs");
          const body = await res.json().catch(() => ({}));
          if (!res.ok || !body.ok || !Array.isArray(body.logs)) {
            logsStatusEl.textContent = body.error || "Failed to load logs.";
            return;
          }
          renderLogs(body.logs);
          logsStatusEl.textContent = `Loaded ${body.logs.length} entries.`;
        } catch (err) {
          logsStatusEl.textContent = "Failed to fetch logs.";
        }
      }

      function renderLogs(logs) {
        logsListEl.innerHTML = "";
        for (const entry of logs) {
          const div = document.createElement("div");
          div.className = "log-entry";
          
          const timeStr = new Date(entry.timestamp).toISOString().split('T')[1].split('Z')[0];
          
          const timeSpan = document.createElement("span");
          timeSpan.className = "log-time";
          timeSpan.textContent = timeStr;
          
          const levelSpan = document.createElement("span");
          levelSpan.className = `log-level log-level-${entry.level}`;
          levelSpan.textContent = entry.level.padEnd(5);
          
          const targetSpan = document.createElement("span");
          targetSpan.className = "log-target";
          targetSpan.textContent = entry.target;

          const msgSpan = document.createElement("span");
          msgSpan.textContent = entry.message;
          
          div.appendChild(timeSpan);
          div.appendChild(levelSpan);
          div.appendChild(targetSpan);
          div.appendChild(msgSpan);
          
          logsListEl.appendChild(div);
        }
        // Auto-scroll to bottom
        logsListEl.scrollTop = logsListEl.scrollHeight;
      }

      loginBtn.addEventListener("click", async () => {
        const secret = secretInput.value.trim();
        if (!secret) {
          statusEl.textContent = "Enter the node identity secret first.";
          return;
        }
        statusEl.textContent = "Logging in…";
        const res = await fetch("/admin-api/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ secret }),
        });
        const body = await res.json().catch(() => ({}));
        if (!res.ok || !body.ok || !body.token) {
          statusEl.textContent = body.error || "Login failed.";
          setLoggedIn(false);
          return;
        }
        localStorage.setItem("veil_admin_token", body.token);
        secretInput.value = "";
        statusEl.textContent = "Authenticated.";
        await refreshStatus();
      });

      logoutBtn.addEventListener("click", async () => {
        try {
          await fetch("/admin-api/logout", {
            method: "POST",
            headers: { Authorization: `Bearer ${token()}` },
          });
        } catch (_) {
          // best-effort server logout
        }
        localStorage.removeItem("veil_admin_token");
        setLoggedIn(false);
        statusEl.textContent = "Logged out.";
      });

      saveSettingBtn.addEventListener("click", async () => {
        const key = settingKeyInput.value.trim();
        const value = settingValueInput.value.trim();
        if (!key) {
          settingsStatusEl.textContent = "Key is required.";
          return;
        }
        settingsStatusEl.textContent = "Saving…";
        const res = await upsertSetting(key, value);
        const body = await res.json().catch(() => ({}));
        if (!res.ok || !body.ok) {
          settingsStatusEl.textContent = body.error || "Save failed.";
          return;
        }
        settingsStatusEl.textContent = `Saved ${key}.`;
        await refreshSettingsList();
      });

      deleteSettingBtn.addEventListener("click", async () => {
        const key = settingKeyInput.value.trim();
        if (!key) {
          settingsStatusEl.textContent = "Key is required.";
          return;
        }
        settingsStatusEl.textContent = "Deleting…";
        const res = await fetch(`/admin-api/settings?key=${encodeURIComponent(key)}`, {
          method: "DELETE",
          headers: { Authorization: `Bearer ${token()}` },
        });
        const body = await res.json().catch(() => ({}));
        if (!res.ok || !body.ok) {
          settingsStatusEl.textContent = body.error || "Delete failed.";
          return;
        }
        settingValueInput.value = "";
        settingsStatusEl.textContent = `Deleted ${key}.`;
        await refreshSettingsList();
      });

      refreshSettingsBtn.addEventListener("click", async () => {
        await refreshSettingsList();
      });

      refreshLogsBtn.addEventListener("click", async () => {
        await refreshLogs();
      });

      copyNsecBtn.addEventListener("click", async () => {
        const value = serverNsecEl.textContent || "";
        if (!value || value === "-") return;
        await navigator.clipboard.writeText(value);
        identityStatusEl.textContent = "nsec copied.";
      });

      copyHexBtn.addEventListener("click", async () => {
        const value = serverHexEl.textContent || "";
        if (!value || value === "-") return;
        await navigator.clipboard.writeText(value);
        identityStatusEl.textContent = "hex secret copied.";
      });

      restartNodeBtn.addEventListener("click", async () => {
        const ok = confirm("Restart VEIL VPS node now? Unsaved in-memory work may be interrupted.");
        if (!ok) return;
        statusEl.textContent = "Restart requested…";
        const res = await fetch("/admin-api/restart", {
          method: "POST",
          headers: { Authorization: `Bearer ${token()}` },
        });
        const body = await res.json().catch(() => ({}));
        if (!res.ok || !body.ok) {
          statusEl.textContent = body.error || "Restart request failed.";
          return;
        }
        statusEl.textContent = "Restart requested. Waiting for node to come back…";
      });

      refreshStatus();
      setInterval(() => {
        if (adminPanelEl.style.display === "block") {
          refreshAdminStats().catch(() => {});
        }
      }, 5000);
    </script>
  </body>
</html>
